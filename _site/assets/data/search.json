[
  
   
      {
        "title"    : "Concurrency &amp; Parallelism",
        "category" : "",
        "tags"     : " Python, Computer Science",
        "url"      : "/2018/12/20/BookStudy_PythonicCoding_chpt03.html",
        "date"     : "December 20, 2018",
        "excerpt"  : "<h1 id=\"study-summary\">Study Summary</h1>\n\n<h1 id=\"03장-동시성과-병렬성\">03장 동시성과 병렬성</h1>\n<!--more-->\n<h3 id=\"chapter-03---concurrency--parallelism\">Chapter 03 - Concurrency &amp; Parallelism</h3>\n\n<p><strong>파이썬답게 코딩하기 (프로그래밍 언어의 개념과 흐름에 대한 고찰), 심경섭 저</...",
        "content"  : "<h1 id=\"study-summary\">Study Summary</h1>\n\n<h1 id=\"03장-동시성과-병렬성\">03장 동시성과 병렬성</h1>\n<!--more-->\n<h3 id=\"chapter-03---concurrency--parallelism\">Chapter 03 - Concurrency &amp; Parallelism</h3>\n\n<p><strong>파이썬답게 코딩하기 (프로그래밍 언어의 개념과 흐름에 대한 고찰), 심경섭 저</strong></p>\n<blockquote>\n  <p>책 속에 그림과 함께 보는게 제일 좋다. 마지막에 정리부분도 잊지마라.</p>\n\n  <p>- 다시 이걸 찾아볼 나에게 -</p>\n</blockquote>\n\n<h3 id=\"개요\">개요</h3>\n<p>동시성(Concurrency)과 병렬성(Parallelism)은 프로그래밍에서 아주 중요한 요소이다. 2가지 특성을 활용해야 한정적인 프로세서(processor) 자원으로 최대한의 성능을 끌어낼 수 있다. 프로세서는 CPU, GPU, NPU 등을 포함하지만 일반적으로 CPU를 기준으로 설명한다.</p>\n\n<h2 id=\"동시성과-병렬성\">동시성과 병렬성</h2>\n\n<h3 id=\"io-bound-vs-cpu-bound\">I/O Bound vs CPU Bound</h3>\n\n<p><strong>I/O Bound</strong> : 입력(Input)/출력(Output)의 영향을 받는 작업. 입력 출력이 완료되기까지 대기하는 시간에 의해 작업시간이 결정됨. 대표적으로 소켓(socket)이나 파일의 입출력과 관계된 작업.</p>\n\n<p><strong>CPU Bound</strong> : CPU의 처리 시간에 따라 작업시간이 결정됨. 대표적으로 암/복호화 연산이나 수학적 연산.</p>\n\n<h3 id=\"병렬성\">병렬성</h3>\n\n<p><strong>병렬성(Parallelism)</strong>은 물리적으로 동시에 여러가지 작업을 연산하는 것. 컴퓨터에서 CPU는 혹은 CPU의 코어는 한번에 하나의 연산만 수행할 수 있다. 병렬성을 구현하려면 동시에 작업할 수 있는 2개 이상의 연산장치 즉, 멀티코어가 필요.</p>\n\n<p>병렬성은 병렬화하는 주체를 어떤 것으로 할지 선택가능. 작업을 병렬화하는 것은 작업 병렬성, 작업하는 데이터를 병렬화하는 것을 데이터 병렬성이라고 함.</p>\n\n<p>작업 병렬성은 동시에 구분된 작업을 수행. 즉 동시에 2가지 이상의 작업을 처리한다. 그래서 각 CPU에서 다른 작업을 수행함.</p>\n\n<p>데이터 병렬성은 동시에 같은 작업을 수행. 하지남 작업을 처리하는 데이터가 각기 다르다. 그래서 각 CPU에서 다른 데이터에 같은 작업을 처리.</p>\n\n<p>결론: 작업을 여러명이서 나눠서 (병렬화) 수행하는 것.</p>\n\n<h3 id=\"동시성\">동시성</h3>\n\n<p><strong>동시성(Concurrency)</strong>은 서로 독립적인 작업을 작은 단위로 나누고 번갈아 가면서 연산하는 것. 컴퓨터의 연산 속도가 매우 빠르기 때문에 작은 단위의 작업을 번갈아 가면서 처리하면 마치 동시에 여러가지 작업을 수행하는 것처럼 보인다. 동시성은 스케줄링을 통해 작업을 나눠서 처리하므로 하나의 CPU에서도 사용이 가능하다.</p>\n\n<p>결론: 혼자 작업을 잘게 나누어 여러가지의 일을 동시에 와리가리 수행하는 것.</p>\n\n<h3 id=\"동시성과-병렬성-1\">동시성과 병렬성</h3>\n<p>병렬성은 CPU 코어 갯수라는 하드웨어에 의존적. but 동시에 작업분배, 결과로딩 등에 대한 소프트웨어적 설계 고려 필요.</p>\n\n<p>동시성은 소프트웨어 의존적. 작업구성, 작업분배 등 고민 필요 —-&gt; 스레드(thread) 탄생</p>\n\n<h2 id=\"process--thread\">Process &amp; Thread</h2>\n\n<h3 id=\"process\">Process</h3>\n<p>프로세스(Process)는 실행 중인 프로그램. 운영체제로부터 자원을 할당받아 프로그램을 실행하는 작업의 최소 단위. 프로세스는 서로 독립적인 메모리와 주소 공간을 할당받음. 프로세스간 정보 교환에는 IPC(Inter-Process Communication)이 필요. 예시, socket, character device, shared memory 등.</p>\n\n<h3 id=\"thread\">Thread</h3>\n<p>스레드(Thread)는 프로세스 안에서 프로세스가 할당받은 자원을 이용하여 프로그램의 명령을 실행하는 최소 단위. 스레드는 한 프로세스 내에서 실행의 흐름, 프로세스 내 주소 공간, 메모리 등 자원을 다른 스레드와 공유. IPC 같은 별도 통신 채널이 불필요하나, 사용하는 자원의 무결성과 동기화를 보장하기 위한 별도의 처리는 필요함.</p>\n\n<h2 id=\"multiprocessing--multithreading\">Multiprocessing &amp; Multithreading</h2>\n\n<p><strong>멀티프로세싱(Multiprocessing)</strong> : 2개 이상의 CPU가 메모리나 기타 입력장치 등을 공유하는 구조이며, 2개 이상의 CPU를 사용하여 병렬성을 구현하는 것.</p>\n<ul>\n  <li>SMP(Symmetric Multiprocessing)</li>\n  <li>ASMP(Asymmetric Multiprocessing)</li>\n</ul>\n\n<p><strong>멀티스레딩(Multithreading)</strong> : 하나의 CPU나 멀티 코어 CPU에서 하나의 코어가 동시에 여러개의 프로세스나 스레드를 처리하는 것.</p>\n<ul>\n  <li>멀티프로세싱은 CPU들이 메모리를 공유.</li>\n  <li>멀티스레딩은 CPU와 코어 안의 작업이 메모리를 공유.</li>\n</ul>\n\n<h2 id=\"multi-tasking\">Multi-tasking</h2>\n\n<p><strong>멀티태스킹(Multi-tasking)</strong> : 동시에 <em>(병렬성이 아닌 동시성)</em> 하나 이상의 일을 처리하는 것. 작업을 나누어서 처리하여 프로세서의 개수보다 동시에 많은 일을 처리하는 것.</p>\n<ul>\n  <li>선점형 (Preemptive Multi-tasking)</li>\n  <li>협력형 (Cooperative Multi-tasking)</li>\n</ul>\n\n<h2 id=\"정리\">정리</h2>\n<ul>\n  <li>멀티프로세싱은 병렬성을 극대화하는 개념.</li>\n  <li>멀티스레딩은 동시성을 극대화하는 개념.</li>\n  <li>CPU 안에서 프로세스는 CPU의 자원인 CPU 캐시(cache)나 TLB 등을 공유, 프로세스 내부에 여러개의 스레드를 띄울 수 있다.</li>\n  <li>스레드들은 프로세스 안에서 동작하고, 프로세스가 할당 받은 메모리나 프로세스의 상태를 공유.</li>\n  <li>멀티스레딩은 작업을 분리하고 공유할 자원을 선별하는 기술에 초점을 맞춘다.</li>\n  <li>멀티태스킹은 나눠진 작업을 어떤 식으로 번갈아가며 작업할지에 조첨을 맞춘다.</li>\n</ul>\n"
      } ,
   
      {
        "title"    : "Level 2. 숫자의 표현 (Python)",
        "category" : "",
        "tags"     : " Algorithm",
        "url"      : "/2018/06/27/NumberExpression.html",
        "date"     : "June 27, 2018",
        "excerpt"  : "<p><strong>문제:</strong>  <br />\n숫자의 표현 (level 2).</p>\n\n<p>문제 설명: <br />\nFinn은 요즘 수학공부에 빠져 있습니다. 수학 공부를 하던 Finn은 자연수 n을 연속한 자연수들로 표현 하는 방법이 여러개라는 사실을 알게 되었습니다. 예를들어 15는 다음과 같이 4가지로 표현 할 수 있습니다. <br />\n<!--more--></p>\n\n<ul>\n  <li>1 + 2 + 3 + 4 + 5 =...",
        "content"  : "<p><strong>문제:</strong>  <br />\n숫자의 표현 (level 2).</p>\n\n<p>문제 설명: <br />\nFinn은 요즘 수학공부에 빠져 있습니다. 수학 공부를 하던 Finn은 자연수 n을 연속한 자연수들로 표현 하는 방법이 여러개라는 사실을 알게 되었습니다. 예를들어 15는 다음과 같이 4가지로 표현 할 수 있습니다. <br />\n<!--more--></p>\n\n<ul>\n  <li>1 + 2 + 3 + 4 + 5 = 15</li>\n  <li>4 + 5 + 6 = 15</li>\n  <li>7 + 8 = 15</li>\n  <li>15 = 15 <br />\n자연수 n이 매개변수로 주어질 때, 연속된 자연수들로 n을 표현하는 방법의 수를 return하는 solution를 완성해주세요.</li>\n</ul>\n\n<p>제한사항</p>\n<ul>\n  <li>n은 10,000 이하의 자연수 입니다.</li>\n</ul>\n\n<p><br /></p>\n\n<p>[접근] <br />\n반복문 중첩을 사용하자. <br />\n첫번째 바깥의 반복문은 덧셈을 시작하는 첫 숫자를 설정하는 반복문. <br />\n두번째 중첩된 반복문은 시작한 숫자부터 연속된 수를 더하는 반복문.</p>\n\n<ul>\n  <li>함수는 인자로 자연수 n을 받는다.</li>\n  <li>표현방법의 수를 변수 answer로 설정하고 0으로 초기화.</li>\n  <li>for문을 사용하여 덧셈을 시작하는 첫 숫자를 루프마다 업데이트한다.\n    <ul>\n      <li>연속된 수의 합을 저장하는 변수 s를 설정하고 0으로 초기화.</li>\n      <li>while문, 조건은 수의 합 s가 n보다 작다로 한다.\n        <ul>\n          <li>변수 s에 첫 숫자가 더해진다.</li>\n          <li>더해지는 숫자는 1씩 커지고 결국 연속된 수의 합이 s에 저장된다.</li>\n          <li>if문, 덧셈결과 s가 n과 같으면, 표현하는 방법이 존재한다는 것이므로 answer에 1을 더해준다.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">solution</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">):</span>\n    <span class=\"n\">answer</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n        <span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"k\">while</span> <span class=\"n\">s</span> <span class=\"o\">&lt;</span> <span class=\"n\">n</span><span class=\"p\">:</span>\n            <span class=\"n\">s</span> <span class=\"o\">+=</span> <span class=\"n\">i</span>\n            <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n            <span class=\"k\">if</span> <span class=\"n\">s</span> <span class=\"o\">==</span> <span class=\"n\">n</span><span class=\"p\">:</span>\n                <span class=\"n\">answer</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n    <span class=\"k\">return</span> <span class=\"n\">answer</span>\n</code></pre></div></div>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># 표현되는 방법들도 알고 싶다면...</span>\n<span class=\"k\">def</span> <span class=\"nf\">solution_2</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">):</span>\n    <span class=\"n\">answer</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"n\">a2</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n        <span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"k\">while</span> <span class=\"n\">s</span> <span class=\"o\">&lt;</span> <span class=\"n\">n</span><span class=\"p\">:</span>\n            <span class=\"n\">s</span> <span class=\"o\">+=</span> <span class=\"n\">i</span>\n            <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n            <span class=\"k\">if</span> <span class=\"n\">s</span> <span class=\"o\">==</span> <span class=\"n\">n</span><span class=\"p\">:</span>\n                <span class=\"n\">answer</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n                <span class=\"n\">a2</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">answer</span><span class=\"p\">,</span> <span class=\"n\">a2</span>\n</code></pre></div></div>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">solution_2</span><span class=\"p\">(</span><span class=\"mi\">30</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>(4, [8, 9, 11, 30])\n</code></pre></div></div>\n\n<p>문제 출처</p>\n<ul>\n  <li>https://programmers.co.kr/learn/courses/30/lessons/12924</li>\n</ul>\n"
      } ,
   
      {
        "title"    : "Level 2. 최고의 집합 (Python)",
        "category" : "",
        "tags"     : " Algorithm",
        "url"      : "/2018/06/19/UtmostSet.html",
        "date"     : "June 19, 2018",
        "excerpt"  : "<p><strong>문제:</strong>  <br />\n최고의 집합 (level 2).</p>\n\n<p>문제 설명:  <br />\n자연수 n 개로 이루어진 집합 중에 다음 두 조건을 만족하는 집합을 최고의 집합이라고 합니다.</p>\n<ul>\n  <li>각 원소의 합이 S가 되는 수의 집합</li>\n  <li>위 조건을 만족하면서 각 원소의 곱 이 최대가 되는 집합  <br />\n<!--more--></li>\n</ul>\n\n<p>예를 들어서 ...",
        "content"  : "<p><strong>문제:</strong>  <br />\n최고의 집합 (level 2).</p>\n\n<p>문제 설명:  <br />\n자연수 n 개로 이루어진 집합 중에 다음 두 조건을 만족하는 집합을 최고의 집합이라고 합니다.</p>\n<ul>\n  <li>각 원소의 합이 S가 되는 수의 집합</li>\n  <li>위 조건을 만족하면서 각 원소의 곱 이 최대가 되는 집합  <br />\n<!--more--></li>\n</ul>\n\n<p>예를 들어서 자연수 2개로 이루어진 집합 중 합이 9가 되는 집합은 다음과 같이 4개가 있습니다. <br />\n{ 1, 8 }, { 2, 7 }, { 3, 6 }, { 4, 5 } <br />\n그중 각 원소의 곱이 최대인 { 4, 5 }가 최고의 집합입니다.</p>\n\n<p>집합의 원소의 개수 n과 모든 원소들의 합 s가 매개변수로 주어질 때, 최고의 집합을 return 하는 solution 함수를 완성해주세요.</p>\n\n<p>제한사항</p>\n<ul>\n  <li>최고의 집합은 오름차순으로 정렬된 1차원 배열(list, vector) 로 return 해주세요.</li>\n  <li>만약 최고의 집합이 존재하지 않는 경우에 크기가 1인 1차원 배열(list, vector) 에 -1 을 채워서 return 해주세요.</li>\n  <li>자연수의 개수 n은 1 이상 10,000 이하의 자연수입니다.</li>\n  <li>모든 원소들의 합 s는 1 이상, 100,000,000 이하의 자연수입니다.</li>\n</ul>\n\n<p><br /></p>\n\n<p>[접근]</p>\n<ul>\n  <li>최고의 집합이 존재하지 않는 경우, [-1]을 반환하는 경우를 먼저 생각해봄.\n    <ul>\n      <li>자연수의 갯수 n이 원소의 합 s보다 크면 최고의 집합이 존재하지 않음.\n        <ul>\n          <li>원소의 합이 s인 집합이 가질 수 있는 최대 자연수 갯수 n은 s이다. ex) [1]*s</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<ol>\n  <li>테스트 케이스를 만들어서 생각해보았다.\n    <ul>\n      <li>n = 3, s = 9, [3, 3, 3]</li>\n      <li>n = 3, s = 10, [3, 3, 4]</li>\n      <li>n = 3, s = 11, [3, 4, 4]</li>\n    </ul>\n  </li>\n  <li>테스트 케이스를 해보면서 알게 된 점이,\n    <ul>\n      <li>s가 n으로 나누어 떨어지면 그 몫이 n개로 이루어진 집합이 답이다.</li>\n      <li>나누어 떨어지지 않으면 그 나머지만큼을 집합내 원소에 더해주면 된다.\n        <ul>\n          <li>대신, 나머지를 원소들에 1씩 골고루 더해줘서 원소의 합 s를 만들어야 집합의 곱이 가장 크다.</li>\n          <li>제한사항에 집합은 오름차순으로 정렬되어야해서, 마지막 인덱스인 원소부터 그 전으로 1씩 더해주었다.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ol>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">solution</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"o\">&gt;</span> <span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"k\">return</span> <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n    <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">s</span><span class=\"o\">//</span><span class=\"n\">n</span><span class=\"p\">]</span><span class=\"o\">*</span><span class=\"n\">n</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">s</span><span class=\"o\">-</span><span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n        <span class=\"n\">a</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n    <span class=\"k\">return</span> <span class=\"n\">a</span>\n</code></pre></div></div>\n\n<p>문제 출처</p>\n<ul>\n  <li>https://programmers.co.kr/learn/courses/30/lessons/12938</li>\n</ul>\n"
      } ,
   
      {
        "title"    : "2018 서머코딩. 영어끝말잇기 (Python)",
        "category" : "",
        "tags"     : " Algorithm",
        "url"      : "/2018/06/16/WordEndtoend.html",
        "date"     : "June 16, 2018",
        "excerpt"  : "<p><strong>문제:</strong> <br />\n영어끝말잇기 (2018 서머코딩).</p>\n\n<p>문제 설명: <br />\n1부터 n까지 번호가 붙어있는 n명의 사람이 영어 끝말잇기를 하고 있습니다. 영어 끝말잇기는 다음과 같은 규칙으로 진행됩니다.\n<!--more--></p>\n\n<ul>\n  <li>1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다.</li>\n  <li>마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작...",
        "content"  : "<p><strong>문제:</strong> <br />\n영어끝말잇기 (2018 서머코딩).</p>\n\n<p>문제 설명: <br />\n1부터 n까지 번호가 붙어있는 n명의 사람이 영어 끝말잇기를 하고 있습니다. 영어 끝말잇기는 다음과 같은 규칙으로 진행됩니다.\n<!--more--></p>\n\n<ul>\n  <li>1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다.</li>\n  <li>마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다.</li>\n  <li>앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다.</li>\n  <li>이전에 등장했던 단어는 사용할 수 없습니다.</li>\n  <li>한 글자인 단어는 인정되지 않습니다.</li>\n</ul>\n\n<p>다음은 3명이 끝말잇기를 하는 상황을 나타냅니다.</p>\n\n<p>tank → kick → know → wheel → land → dream → mother → robot → tank</p>\n\n<p>위 끝말잇기는 다음과 같이 진행됩니다.</p>\n\n<ul>\n  <li>1번 사람이 자신의 첫 번째 차례에 tank를 말합니다.</li>\n  <li>2번 사람이 자신의 첫 번째 차례에 kick을 말합니다.</li>\n  <li>3번 사람이 자신의 첫 번째 차례에 know를 말합니다.</li>\n  <li>1번 사람이 자신의 두 번째 차례에 wheel을 말합니다.</li>\n  <li>(계속 진행)</li>\n</ul>\n\n<p>끝말잇기를 계속 진행해 나가다 보면, 3번 사람이 자신의 세 번째 차례에 말한 tank 라는 단어는 이전에 등장했던 단어이므로 탈락하게 됩니다.</p>\n\n<p>사람의 수 n과 사람들이 순서대로 말한 단어 words 가 매개변수로 주어질 때, 가장 먼저 탈락하는 사람의 번호와 그 사람이 자신의 몇 번째 차례에 탈락하는지를 구해서 return 하도록 solution 함수를 완성해주세요.</p>\n\n<p>제한 사항</p>\n<ul>\n  <li>끝말잇기에 참여하는 사람의 수 n은 2 이상 10 이하의 자연수입니다.</li>\n  <li>words는 끝말잇기에 사용한 단어들이 순서대로 들어있는 배열이며, 길이는 n 이상 100 이하입니다.</li>\n  <li>단어의 길이는 2 이상 50 이하입니다.</li>\n  <li>모든 단어는 알파벳 소문자로만 이루어져 있습니다.</li>\n  <li>끝말잇기에 사용되는 단어의 뜻(의미)은 신경 쓰지 않으셔도 됩니다.</li>\n  <li>정답은 [ 번호, 차례 ] 형태로 return 해주세요.</li>\n  <li>만약 주어진 단어들로 탈락자가 생기지 않는다면, [0, 0]을 return 해주세요.</li>\n</ul>\n\n<p>입출력 예</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>n</th>\n      <th>words</th>\n      <th>result</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>3</td>\n      <td>[tank, kick, know, wheel, land, dream, mother, robot, tank]</td>\n      <td>[3,3]</td>\n    </tr>\n    <tr>\n      <td>5</td>\n      <td>[hello, observe, effect, take, either, recognize, encourage, ensure, establish, hang, gather, refer, reference, estimate, executive]</td>\n      <td>[0,0]</td>\n    </tr>\n    <tr>\n      <td>2</td>\n      <td>[hello, one, even, never, now, world, draw]</td>\n      <td>[1,3]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>입출력 예 설명</p>\n\n<p>입출력 예 #1 <br />\n3명의 사람이 끝말잇기에 참여하고 있습니다.</p>\n\n<ul>\n  <li>1번 사람 : tank, wheel, mother</li>\n  <li>2번 사람 : kick, land, robot</li>\n  <li>3번 사람 : know, dream, tank</li>\n</ul>\n\n<p>와 같은 순서로 말을 하게 되며, 3번 사람이 자신의 세 번째 차례에 말한 tank라는 단어가 1번 사람이 자신의 첫 번째 차례에 말한 tank와 같으므로 3번 사람이 자신의 세 번째 차례로 말을 할 때 처음 탈락자가 나오게 됩니다.</p>\n\n<p>입출력 예 #2 <br />\n5명의 사람이 끝말잇기에 참여하고 있습니다.</p>\n\n<ul>\n  <li>1번 사람 : hello, recognize, gather</li>\n  <li>2번 사람 : observe, encourage, refer</li>\n  <li>3번 사람 : effect, ensure, reference</li>\n  <li>4번 사람 : take, establish, estimate</li>\n  <li>5번 사람 : either, hang, executive</li>\n</ul>\n\n<p>와 같은 순서로 말을 하게 되며, 이 경우는 주어진 단어로만으로는 탈락자가 발생하지 않습니다. 따라서 [0, 0]을 return하면 됩니다.</p>\n\n<p>입출력 예 #3 <br />\n2명의 사람이 끝말잇기에 참여하고 있습니다.</p>\n\n<ul>\n  <li>1번 사람 : hello, even, now, draw</li>\n  <li>2번 사람 : one, never, world</li>\n</ul>\n\n<p>와 같은 순서로 말을 하게 되며, 1번 사람이 자신의 세 번째 차례에 ‘r’로 시작하는 단어 대신, n으로 시작하는 now를 말했기 때문에 이때 처음 탈락자가 나오게 됩니다.</p>\n\n<p><br /></p>\n\n<p>[접근]</p>\n<ul>\n  <li>for문이 break하는 경우는, (편의를 위해 두번째 단어부터 검사함.)\n    <ul>\n      <li>앞단어 마지막 철자와 뒷단어의 첫 철자가 다른 경우, (previous_word[-1] != current_word[0])</li>\n      <li>elif(OR), 해당 차례의 단어가 이전까지의 단어리스트에서 검출된 경우.</li>\n      <li>해당 index를 결과 도출에 활용함.(계산 상 편의를 위해 index에 +1)</li>\n    </ul>\n  </li>\n</ul>\n\n<ol>\n  <li>break 경우가 없을 시, [0,0] 반환.</li>\n  <li>n번 사람이 틀린 경우, 틀린 단어의 순서가 n으로 나누어 떨어짐. (틀린 단어 순서 % n == 0)\n    <ul>\n      <li>[n번 사람이, 틀린 단어 순서//n 번째 차례에 틀림]</li>\n    </ul>\n  </li>\n  <li>n번이 아닌 다른 사람이 틀린 경우. (틀린 단어 순서 % n != 0)\n    <ul>\n      <li>[틀린 단어 순서를 n으로 나눈 나머지(%), (틀린 단어 순서//n)+1 번째 차례에 틀림]</li>\n    </ul>\n  </li>\n</ol>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">solution</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">words</span><span class=\"p\">):</span>\n    <span class=\"n\">wrong</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">words</span><span class=\"p\">)):</span>\n        <span class=\"k\">if</span> <span class=\"n\">words</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">!=</span> <span class=\"n\">words</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]:</span>\n            <span class=\"n\">wrong</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span>\n            <span class=\"k\">break</span>\n        <span class=\"k\">elif</span> <span class=\"n\">words</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"ow\">in</span> <span class=\"n\">words</span><span class=\"p\">[:</span><span class=\"n\">i</span><span class=\"p\">]:</span>\n            <span class=\"n\">wrong</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span>\n            <span class=\"k\">break</span>\n    <span class=\"k\">if</span> <span class=\"n\">wrong</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n    <span class=\"k\">if</span> <span class=\"n\">wrong</span><span class=\"o\">%</span><span class=\"n\">n</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"p\">[</span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"n\">wrong</span><span class=\"o\">//</span><span class=\"n\">n</span><span class=\"p\">]</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"p\">[</span><span class=\"n\">wrong</span><span class=\"o\">%</span><span class=\"n\">n</span><span class=\"p\">,(</span><span class=\"n\">wrong</span><span class=\"o\">//</span><span class=\"n\">n</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n</code></pre></div></div>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># 약 0.01ms 더 빠르게 나옴.</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">solution</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">words</span><span class=\"p\">):</span>\n    <span class=\"n\">wrong</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">words</span><span class=\"p\">)):</span>\n        <span class=\"k\">if</span> <span class=\"n\">words</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">!=</span> <span class=\"n\">words</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"ow\">or</span> <span class=\"n\">words</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"ow\">in</span> <span class=\"n\">words</span><span class=\"p\">[:</span><span class=\"n\">i</span><span class=\"p\">]:</span>\n            <span class=\"n\">wrong</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span>\n            <span class=\"k\">break</span>\n    <span class=\"k\">if</span> <span class=\"n\">wrong</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n    <span class=\"k\">if</span> <span class=\"n\">wrong</span><span class=\"o\">%</span><span class=\"n\">n</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"p\">[</span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"n\">wrong</span><span class=\"o\">//</span><span class=\"n\">n</span><span class=\"p\">]</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"p\">[</span><span class=\"n\">wrong</span><span class=\"o\">%</span><span class=\"n\">n</span><span class=\"p\">,(</span><span class=\"n\">wrong</span><span class=\"o\">//</span><span class=\"n\">n</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n</code></pre></div></div>\n\n<p>문제 출처</p>\n<ul>\n  <li>https://programmers.co.kr/learn/courses/30/lessons/12981</li>\n</ul>\n"
      } ,
   
      {
        "title"    : "Level 2. 땅따먹기 (Python)",
        "category" : "",
        "tags"     : " Algorithm",
        "url"      : "/2018/06/15/Landing.html",
        "date"     : "June 15, 2018",
        "excerpt"  : "<p><strong>문제:</strong>  <br />\n땅따먹기 (level 2).</p>\n\n<p>문제 설명: <br />\n땅따먹기 게임을 하려고 합니다. 땅따먹기 게임의 땅(land)은 총 N행 4열로 이루어져 있고, 모든 칸에는 점수가 쓰여 있습니다. 1행부터 땅을 밟으며 한 행씩 내려올 때, 각 행의 4칸 중 한 칸만 밟으면서 내려와야 합니다. 단, 땅따먹기 게임에는 한 행씩 내려올 때, 같은 열을 연속해서 밟을 수 없는 특수 규칙...",
        "content"  : "<p><strong>문제:</strong>  <br />\n땅따먹기 (level 2).</p>\n\n<p>문제 설명: <br />\n땅따먹기 게임을 하려고 합니다. 땅따먹기 게임의 땅(land)은 총 N행 4열로 이루어져 있고, 모든 칸에는 점수가 쓰여 있습니다. 1행부터 땅을 밟으며 한 행씩 내려올 때, 각 행의 4칸 중 한 칸만 밟으면서 내려와야 합니다. 단, 땅따먹기 게임에는 한 행씩 내려올 때, 같은 열을 연속해서 밟을 수 없는 특수 규칙이 있습니다.\n<!--more-->\n예를 들면,</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>1</td>\n      <td>2</td>\n      <td>3</td>\n      <td>5</td>\n    </tr>\n  </tbody>\n</table>\n\n<table>\n  <tbody>\n    <tr>\n      <td>5</td>\n      <td>6</td>\n      <td>7</td>\n      <td>8</td>\n    </tr>\n  </tbody>\n</table>\n\n<table>\n  <tbody>\n    <tr>\n      <td>4</td>\n      <td>3</td>\n      <td>2</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>로 땅이 주어졌다면, 1행에서 네번째 칸 (5)를 밟았으면, 2행의 네번째 칸 (8)은 밟을 수 없습니다.</p>\n\n<p>마지막 행까지 모두 내려왔을 때, 얻을 수 있는 점수의 최대값을 return하는 solution 함수를 완성해 주세요.  <br />\n위 예의 경우, 1행의 네번째 칸 (5), 2행의 세번째 칸 (7), 3행의 첫번째 칸 (4) 땅을 밟아 16점이 최고점이 되므로 16을 return 하면 됩니다.</p>\n\n<p>제한사항 <br />\n행의 개수 N : 100,000 이하의 자연수 <br />\n열의 개수는 4개이고, 땅(land)은 2차원 배열로 주어집니다. <br />\n점수 : 100 이하의 자연수</p>\n\n<p><br /></p>\n\n<p>[접근]</p>\n<ol>\n  <li>이전행의 max값 중복여부와 인덱스, 현재행의 max값 중복여부와 인덱스, 차상위 max값 선택이 필요한 경우 등을 기준으로 고려해야할 경우를 뽑음.\n    <ul>\n      <li>두 행 모두 max값 중복보유 및 인덱스 겹침</li>\n      <li>두 행 모두 max값 중복보유 및 인덱스 안 겹침</li>\n      <li>이전행 max값 중복보유</li>\n      <li>현재행 max값 중복보유</li>\n      <li>이전행 차상위 max값 선택필요한 경우</li>\n      <li>현재행 차상위 max값 선택필요한 경우</li>\n    </ul>\n  </li>\n  <li>if문 계속 달면서 규칙을 만들다가 내가 뭐하는 건지 멘붕옴.</li>\n  <li>어차피 이전행의 각 원소들을 다음행의 해당 원소의 인덱스를 제외한 max값을 더해주면 되는 거라는 거를 깨달음.\n    <ul>\n      <li>Dynamic Programming을 적용함.</li>\n      <li>변수 cp에 land를 복사함.</li>\n      <li>첫 for문에서 r행의 시작을 0번째 행이 아닌 1번째 행부터 시작하게함.\n        <ul>\n          <li>대신, 변수 temp에 r-1 행을 복사함.</li>\n          <li>두번째 for문에서, r행의 원소들을 업데이트함.\n            <ul>\n              <li>기존 r행의 원소에, 이전행의 값을 가진 (앞에서 계속 업데이트된) temp에서, r행의 해당 원소와 같은 인덱스의 원소를 제외하고 최대값을 더해서 업데이트함.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>최종 업데이트된 cp의 마지막 줄에서 최대값을 return함.</li>\n    </ul>\n  </li>\n</ol>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">solution</span><span class=\"p\">(</span><span class=\"n\">land</span><span class=\"p\">):</span>\n    <span class=\"n\">cp</span> <span class=\"o\">=</span> <span class=\"p\">[[</span><span class=\"n\">x</span> <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"n\">row</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">row</span> <span class=\"ow\">in</span> <span class=\"n\">land</span><span class=\"p\">]</span>\n\n    <span class=\"k\">for</span> <span class=\"n\">r</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">land</span><span class=\"p\">)):</span>\n        <span class=\"n\">temp</span> <span class=\"o\">=</span> <span class=\"n\">cp</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][:]</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">land</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])):</span>\n            <span class=\"n\">cp</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">][</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">cp</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">][</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">temp</span><span class=\"p\">[:</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">temp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">:])</span>\n    <span class=\"k\">return</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">cp</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n</code></pre></div></div>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># test case</span>\n<span class=\"n\">land</span> <span class=\"o\">=</span> <span class=\"p\">[[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">],[</span><span class=\"mi\">8</span><span class=\"p\">,</span><span class=\"mi\">8</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">],[</span><span class=\"mi\">6</span><span class=\"p\">,</span><span class=\"mi\">7</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">],[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"mi\">7</span><span class=\"p\">]]</span>\n\n<span class=\"n\">cp</span> <span class=\"o\">=</span> <span class=\"p\">[[</span><span class=\"n\">x</span> <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"n\">row</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">row</span> <span class=\"ow\">in</span> <span class=\"n\">land</span><span class=\"p\">]</span>\n<span class=\"k\">for</span> <span class=\"n\">r</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">land</span><span class=\"p\">)):</span>\n    <span class=\"n\">temp</span> <span class=\"o\">=</span> <span class=\"n\">cp</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][:]</span>\n    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">,</span><span class=\"s\">\"번째\"</span><span class=\"p\">)</span>\n    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">cp</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">],</span><span class=\"n\">cp</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">])</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">land</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])):</span>\n        <span class=\"n\">cp</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">][</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">cp</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">][</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">temp</span><span class=\"p\">[:</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">temp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">:])</span>\n    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">cp</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">])</span>\n    <span class=\"k\">print</span><span class=\"p\">()</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">'최종: '</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"o\">=</span><span class=\"s\">''</span><span class=\"p\">)</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">cp</span><span class=\"p\">)</span>\n\n<span class=\"n\">solution</span><span class=\"p\">(</span><span class=\"n\">land</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1 번째\n[1, 2, 3, 4] [8, 8, 3, 2]\n[12, 12, 7, 5]\n\n2 번째\n[12, 12, 7, 5] [6, 7, 4, 5]\n[18, 19, 16, 17]\n\n3 번째\n[18, 19, 16, 17] [1, 3, 5, 7]\n[20, 21, 24, 26]\n\n최종: [[1, 2, 3, 4], [12, 12, 7, 5], [18, 19, 16, 17], [20, 21, 24, 26]]\n\n\n\n\n\n26\n</code></pre></div></div>\n\n<p>문제 출처</p>\n<ul>\n  <li>https://programmers.co.kr/learn/courses/30/lessons/12913</li>\n</ul>\n"
      } ,
   
      {
        "title"    : "Level 2. 가장 큰 정사각형 찾기 (Python)",
        "category" : "",
        "tags"     : " Algorithm",
        "url"      : "/2018/06/11/MaxSquareFinder.html",
        "date"     : "June 11, 2018",
        "excerpt"  : "<p><strong>문제:</strong> <br />\n가장 큰 정사각형 (level 2).</p>\n\n<p>문제 설명: <br />\n1와 0로 채워진 표(board)가 있습니다. 표 1칸은 1 x 1 의 정사각형으로 이루어져 있습니다. 표에서 1로 이루어진 가장 큰 정사각형을 찾아 넓이를 return 하는 solution 함수를 완성해 주세요. (단, 정사각형이란 축에 평행한 정사각형을 말합니다.)\n<!--more-->\n예를 들어</p>\n...",
        "content"  : "<p><strong>문제:</strong> <br />\n가장 큰 정사각형 (level 2).</p>\n\n<p>문제 설명: <br />\n1와 0로 채워진 표(board)가 있습니다. 표 1칸은 1 x 1 의 정사각형으로 이루어져 있습니다. 표에서 1로 이루어진 가장 큰 정사각형을 찾아 넓이를 return 하는 solution 함수를 완성해 주세요. (단, 정사각형이란 축에 평행한 정사각형을 말합니다.)\n<!--more-->\n예를 들어</p>\n\n<p>1\t2\t3\t4 <br />\n0\t1\t1\t1 <br />\n1\t1\t1\t1 <br />\n1\t1\t1\t1 <br />\n0\t0\t1\t0</p>\n\n<p>가 있다면 가장 큰 정사각형은</p>\n\n<p>1\t2\t3\t4 <br />\n0\t<del>1\t1\t1</del> <br />\n1\t<del>1\t1\t1</del> <br />\n1\t<del>1\t1\t1</del> <br />\n0\t0\t1\t0</p>\n\n<p>가 되며 넓이는 9가 되므로 9를 반환해 주면 됩니다.</p>\n\n<p>제한사항 <br />\n표(board)는 2차원 배열로 주어집니다. <br />\n표(board)의 행(row)의 크기 : 1000 이하의 자연수 <br />\n표(board)의 열(column)의 크기 : 1000 이하의 자연수 <br />\n표(board)의 값은 1또는 0으로만 이루어져 있습니다.</p>\n\n<p>입출력 예</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>board</th>\n      <th>answer</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>[[0,1,1,1],[1,1,1,1],[1,1,1,1],[0,0,1,0]]</td>\n      <td>9</td>\n    </tr>\n    <tr>\n      <td>[[0,0,1,1],[1,1,1,1]]</td>\n      <td>4</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>입출력 예 설명 <br />\n입출력 예 #1 <br />\n위의 예시와 같습니다.</p>\n\n<p>입출력 예 #2 <br />\n| 0 | 0 <del>| 1 | 1 |</del> <br />\n| 1 | 1 <del>| 1 | 1 |</del>  <br />\n로 가장 큰 정사각형의 넓이는 4가 되므로 4를 return합니다.</p>\n\n<p><br /></p>\n\n<p>[접근]</p>\n<ol>\n  <li>컨볼루션 레이어처럼 계산해보면 어떨까?\n    <ul>\n      <li>주어진 배열에서 만들 수 있는 가장 큰 정사각형을 만들어서 그 배열의 합이 넓이와 같은 경우를 찾자!</li>\n      <li>정사각형을 이동시키면서 그리고 가로 세로 길이를 1씩 줄이면서 구해보자!</li>\n      <li>근데 이게 대충 생각만 해봐도 매우 비효율적인게 느껴짐… (배열합 구하는 거를 몇번을 해야하는겨?)</li>\n    </ul>\n  </li>\n  <li>깊이 우선, 너비 우선 탐색을 적용해볼까?\n    <ul>\n      <li>해보다가 깊이 우선, 너비 우선 복습만 함…</li>\n    </ul>\n  </li>\n  <li>결국 다른 분이 풀어서 블로그에 올리신 <a href=\"http://whatisthenext.tistory.com/138\">포스팅</a> 참고함.\n    <ul>\n      <li>Dynamic Programming을 통해 푸신 글을 봄.</li>\n      <li>신세계 열림… ㅎㄷㄷ…</li>\n      <li>DP를 자료구조 공부하면서 배웠지만 자세히 공부 안함… 반성함…</li>\n    </ul>\n  </li>\n</ol>\n\n<p>결론 -  Dynamic Programming이 재귀보다 좋고, 매우 뛰어난 방법임을 깨닳음.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">solution</span><span class=\"p\">(</span><span class=\"n\">board</span><span class=\"p\">):</span>\n    <span class=\"c\"># check whether board is consist of only zeros</span>\n    <span class=\"n\">_s</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">board</span><span class=\"p\">)):</span>\n        <span class=\"n\">_s</span> <span class=\"o\">+=</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">board</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][:])</span>\n    <span class=\"k\">if</span> <span class=\"n\">_s</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"mi\">0</span>\n    \n    <span class=\"n\">_s</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>  <span class=\"c\"># initialize _s to 0</span>\n    \n    <span class=\"n\">table</span> <span class=\"o\">=</span> <span class=\"p\">[[</span><span class=\"n\">x</span> <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"n\">sub</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">sub</span> <span class=\"ow\">in</span> <span class=\"n\">board</span><span class=\"p\">]</span>\n    <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">table</span><span class=\"p\">)):</span>\n        <span class=\"k\">for</span> <span class=\"n\">y</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">table</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">])):</span>\n            <span class=\"k\">if</span> <span class=\"n\">table</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">][</span><span class=\"n\">y</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n                <span class=\"k\">continue</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">_min</span> <span class=\"o\">=</span> <span class=\"nb\">min</span><span class=\"p\">([</span><span class=\"n\">table</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">][</span><span class=\"n\">y</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">table</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"n\">y</span><span class=\"p\">],</span> <span class=\"n\">table</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"n\">y</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]])</span>\n                <span class=\"n\">table</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">][</span><span class=\"n\">y</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">_min</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n                <span class=\"k\">if</span> <span class=\"n\">_s</span> <span class=\"o\">&lt;</span> <span class=\"n\">table</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">][</span><span class=\"n\">y</span><span class=\"p\">]:</span>\n                    <span class=\"n\">_s</span> <span class=\"o\">=</span> <span class=\"n\">table</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">][</span><span class=\"n\">y</span><span class=\"p\">]</span>\n                    \n    <span class=\"c\"># if board looks like identity matrix _s would be 0, but max square would be 1.</span>\n    <span class=\"k\">if</span> <span class=\"n\">_s</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"mi\">1</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">_s</span> <span class=\"o\">**</span> <span class=\"mi\">2</span>\n</code></pre></div></div>\n\n<p>문제 출처</p>\n<ul>\n  <li>https://programmers.co.kr/learn/courses/30/lessons/12905</li>\n</ul>\n"
      } ,
   
      {
        "title"    : "Dropout, &quot;Improving neural networks by preventing co-adaptation of feature detectors&quot; (2012)",
        "category" : "",
        "tags"     : " Paper_Review",
        "url"      : "/2018/06/05/ImprovingNeuralNetowrksbyPreventingCoadaptationofFeatureDetectors.html",
        "date"     : "June 5, 2018",
        "excerpt"  : "<p>Review: 신경망에서 드롭아웃에 관한 첫번째 논문이다. 이후 정리한 논문이 더 자세한 것 같다. 학습단계에서 무작위로 은닉층의 뉴런, 특징추출기 중 절반을 생략한다. 이를 통해 드롭아웃이 미적용된 망에서 보이던 동조화 현상이 현저히 줄어드는 것을 보았고, 자체적으로 앙상블 모델과 같은 모델 평균 효과를 보여준다. 이 두 작용을 통해 과최적화, Overfitting을 방지하는 결과를 보여준다. \n<!--more--></p>\n<h1 ...",
        "content"  : "<p>Review: 신경망에서 드롭아웃에 관한 첫번째 논문이다. 이후 정리한 논문이 더 자세한 것 같다. 학습단계에서 무작위로 은닉층의 뉴런, 특징추출기 중 절반을 생략한다. 이를 통해 드롭아웃이 미적용된 망에서 보이던 동조화 현상이 현저히 줄어드는 것을 보았고, 자체적으로 앙상블 모델과 같은 모델 평균 효과를 보여준다. 이 두 작용을 통해 과최적화, Overfitting을 방지하는 결과를 보여준다. \n<!--more--></p>\n<h1 id=\"dropout-improving-neural-networks-by-preventing-co-adaptation-of-feature-detectors\">Dropout: Improving neural networks by preventing co-adaptation of feature detectors</h1>\n<ul>\n  <li>References\n    <ul>\n      <li>Hinton, Geoffrey E., et al. “Improving neural networks by preventing co-adaptation of feature detectors.” (2012). <a href=\"https://arxiv.org/pdf/1207.0580.pdf\">[pdf]</a></li>\n    </ul>\n  </li>\n</ul>\n\n<p><strong>Abstract</strong></p>\n<ul>\n  <li>작은 데이터셋으로 feedforward 뉴럴넷을 학습시켰을 시, 테스트셋에서 성과가 저조하다. 이런 “과적화(Overfitting)”는, 각각의 트레이닝 케이스(예시: mini batch)마다 무작위로 절반의 특징추출기(feature detectors)를 생략하는 “드롭아웃(dropout)”을 통해 줄일 수 있다. 이 방법은 특징추출기들의 동조화(co-adaptation)을 막는다.</li>\n  <li>Dropout을 적용했더니, 음성 인식과 이미지 인식에서 향상된 결과를 보였다.</li>\n  <li>Co-adaptation, 동조화: 특정 뉴런의 가중치나 바이어스가 큰 값을 갖게 되면, 그 특정 뉴런의 영향이 커지면서 다른 뉴런들의 학습 속도가 느려지거나 학습이 제대로 진행되지 못하는 경우.</li>\n</ul>\n\n<p><strong>Overfitting의 원인에 관하여</strong></p>\n<ul>\n  <li>feedforward neural network(input units + hidden units + output units)는 입력층과 은닉층 그리고 출력층으로 구성된다. 은닉층은 입력층에 입력된 값은 바탕으로 가중치를 조정하고 출력층이 정확한 출력을 예측하게 특징추출기를 학습한다.</li>\n  <li>입력과 출력의 관계가 복잡하거나 라벨링된 학습데이터가 부족하다면, 모델은 트레인셋에 특화되므로 테스트셋에서 아주 저조한 성과를 보일 것이다. 이를 “Overfitting”이라고 한다.</li>\n</ul>\n\n<p><strong>Dropout의 장점과 기능 2가지</strong>  </p>\n<ul>\n  <li>드롭아웃은 학습데이터의 복잡한 co-adaptatio을 방지하여 overfitting을 방지한다.\n    <ul>\n      <li>일정한 training case(예: mini-batch)마다 은닉뉴런을 무작위로 50% 확률로 생략시킨다. 이를 통해 은닉뉴런들이 특정 혹은 다른 은닉뉴런에 동조하는 것을 막을 수 있다.</li>\n    </ul>\n  </li>\n  <li>드롭아웃을 보는 다른 관점으로, 모델 평균효과(model averaging)를 들 수 있다.\n    <ul>\n      <li>테스트셋에서 에러를 줄이는 방법으로 앙상블, 여러 다른 형태의 네트워크의 결과를 평균내는 방법이 있다. 하지만 이 방법은 너무 비용이 크다.</li>\n      <li>드롭아웃은 적절한 시간을 들여 다양한 망을 학습하게 해준다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p><strong>Regularization 적용에 관하여</strong>  </p>\n<ul>\n  <li>드롭아웃 뉴럴넷에는 기본적으로 SGD와 mini-batch training case를 적용했으나, L2 norm 대신 다른 패널티 방식, Regularization 방식을 적용했다. (Max norm 방식)\n    <ul>\n      <li>은닉레이어에 L2 norm이 적용된, 가중치 벡터에 상한치(upper boundary)를 적용하여 이를 넘지 못하게 했다.</li>\n      <li>이 방식을 통해 가중치가 너무 커지는 것을 방지하여, learning rate을 큰 값부터 사용하는 것이 가능하게 되고, 학습 속도를 빠르게 할 수 있게 되었다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p><strong>Mean network 효과(평균 망 효과)에 대하여</strong>  </p>\n<ul>\n  <li>테스트 시에는, 모든 은닉뉴런을 사용했지만 그 가중치를 절반으로 줄였다.</li>\n  <li>… (이부분 잘 이해안됨)</li>\n</ul>\n\n<p><strong>MNIST 적용 결과</strong>  </p>\n<ul>\n  <li>MNIST\n    <ul>\n      <li>60,000 28x28 training images of individual hand written digits</li>\n      <li>10,000 test images</li>\n    </ul>\n  </li>\n  <li>기존 feedforward 신경망을 통한 테스트셋에서 160 errors</li>\n  <li>드롭아웃 50%, max norm 적용하여 130 errors</li>\n  <li>\n    <ul>\n      <li>20%의 픽셀에 드롭아웃을 적용하여 110 errors</li>\n    </ul>\n  </li>\n</ul>\n\n<p><strong>MNIST Pre-trianing과의 조합</strong>  </p>\n<ul>\n  <li>50% 드롭아웃과 작은 학습율, 가중치제한 없이 pre-trained 모델에 적용하여, 118 errors에서 92 errors로 결과 향상.</li>\n  <li>이외 이어서 미적용모델과 적용모델을 계속 학습시켰으나, 드롭아웃 적용 모델이 더 성능이 좋았음.</li>\n</ul>\n\n<p><strong>TIMIT 적용 결과</strong>  </p>\n<ul>\n  <li>TIMIT\n    <ul>\n      <li>짧은 단어로 이루어진 음성 데이터셋</li>\n    </ul>\n  </li>\n  <li>당시에 음성인식에 hidden Markov models을 사용함. 자세한 내용은 생략…</li>\n  <li>총 4개의 FC 은닉층에 4000개의 뉴런, 185개의 softmax 출력뉴런으로 39개의 라벨을 분류함</li>\n  <li>암튼 드롭아웃을 적용하여 22.7%에서 19.7%로 성능 향상</li>\n</ul>\n\n<p><strong>CIFAR-10 적용 결과</strong>  </p>\n<ul>\n  <li>CIFAR-10\n    <ul>\n      <li>50,000 32x32 training images of color object</li>\n      <li>10,000 test images with 10 classes</li>\n    </ul>\n  </li>\n  <li>구형 망을 통한 테스트에서 18.5%</li>\n  <li>3 Convolution layers + 3 Max-pooling layers + 1 locally connected layers, 16.6%</li>\n  <li>\n    <ul>\n      <li>dropout in last hidden layer 15.6%</li>\n    </ul>\n  </li>\n</ul>\n\n<p><strong>ImageNet</strong>  </p>\n<ul>\n  <li>ImageNet(2010)\n    <ul>\n      <li>1000 images on each 1000 classes</li>\n    </ul>\n  </li>\n  <li>5 Conv. layer with max-pooling layer + 2 globally connected layers + 1000 way softmax layer. + 가중치제한 + 50% 드롭아웃. 47.2% -&gt; 42.4%</li>\n</ul>\n\n<p><strong>Reuters</strong>  </p>\n<ul>\n  <li>Reuters dataset(로이터 통신 데이터셋)\n    <ul>\n      <li>201,369 docs with 50 상호배타적인 classes</li>\n    </ul>\n  </li>\n  <li>50% 드롭아웃 적용. 31.05% -&gt; 29.62%</li>\n</ul>\n\n<p><strong>실험에 의한 dropout 평가</strong>  </p>\n<ul>\n  <li>확실히 dropout 적용시 성능이 좋아짐.\n    <ul>\n      <li>FC의 모든 은닉층에 적용함이 하나의 은닉층에 적용함 보다 성능향상에 좋음.</li>\n      <li>극단적인 드롭아웃 적용은 성능을 저하시킴. 그래서 0.5 씩 적용함.</li>\n      <li>입력에도 드롭아웃 적용 시, 성능향상에 도움을 주기도 함.</li>\n      <li>validation set의 결과를 보고 각 은닉층과 입력층에 적용하는 드롭아웃율을 조절하는 방법도 가능함.</li>\n    </ul>\n  </li>\n</ul>\n\n<p><strong>기타 논의</strong>  </p>\n<ul>\n  <li>학습 데이터로 얻은 사후 확률로 각 모델의 가중치를 정하는 베이지안 모델 평균방식보다, 드롭아웃은 적용하기 더 단순하다.\n    <ul>\n      <li>복잡한 모델에서, 베이지안 방식은 사후 확률분포에서 모델을 샘플링하는데에 마코프 체인 몬테 카를로 방법을 사용한다.</li>\n      <li>반면, 드롭아웃은 각 모델이 0.5의 확률로 같은 중요도로 결합되고, 학습 시 이런한 점이 전제된다.</li>\n      <li>테스트에서, 드롭아웃의 결정은 각 단위에 독립적이므로 mean net을 통한 단일 통과를 사용하여 지수함수적으로 다양한 dropout망의 결합 옵션을 최적화하는 것이 쉽다. (한번에 통과하면서 좋은 성능을 보여줄 수 있따?)</li>\n    </ul>\n  </li>\n  <li>베이지안 모델 평균의 대안으로 “bagging”이 있다.\n    <ul>\n      <li>드롭아웃은 극단적인 형태의 bagging이라고 볼수 있다. 한번의 학습에 각 모델의 파라미터는 다른 모델의 파라미터와 공유하며 강하게 정규화된다.</li>\n    </ul>\n  </li>\n  <li>양성 생식 진화 이론과 견주어 비교해 볼 수 있다.</li>\n</ul>\n"
      } ,
   
      {
        "title"    : "VGGNet, &quot;Very Deep Convolutional Networks for Large-Scale Image Recognition&quot; (2014)",
        "category" : "",
        "tags"     : " Paper_Review",
        "url"      : "/2018/05/29/VeryDeepConvolutionalNetworksforLargeScaleImageRecognition_VGGNet.html",
        "date"     : "May 29, 2018",
        "excerpt"  : "<p>Review: VGGNet은 구조가 간단하며 이해나 변형이 쉬운 장점을 가진다. 하지만 FC로 인해 파라미터의 수가 매우 많다는 단점을 가지며, 이로 인해 필요한 메모리 수가 크고, 학습 시간이 오래 걸린다는 약점을 가진다.</p>\n\n<!--more-->\n<h1 id=\"vggnet-very-deep-convolutional-networks-for-large-scale-image-recognition\">VGGNet: Very Deep ...",
        "content"  : "<p>Review: VGGNet은 구조가 간단하며 이해나 변형이 쉬운 장점을 가진다. 하지만 FC로 인해 파라미터의 수가 매우 많다는 단점을 가지며, 이로 인해 필요한 메모리 수가 크고, 학습 시간이 오래 걸린다는 약점을 가진다.</p>\n\n<!--more-->\n<h1 id=\"vggnet-very-deep-convolutional-networks-for-large-scale-image-recognition\">VGGNet: Very Deep Convolutional Networks for Large-Scale Image Recognition</h1>\n<ul>\n  <li>References\n    <ul>\n      <li>Simonyan, Karen, and Andrew Zisserman. “Very deep convolutional networks for large-scale image recognition.” (2014). <a href=\"https://arxiv.org/pdf/1409.1556.pdf\">[pdf]</a></li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"abstract\">Abstract</h2>\n<ul>\n  <li>주요 연구 목적은 망의 깊이(depth)가 정확도에 미치는 영향력이다.</li>\n  <li>주요 연구 성과는 3x3 convolution filter를 사용한 구조에서 망의 깊이를 증가시켰을 때 보여진 향상된 결과와 그 평가이다. (16~19 레이어)</li>\n  <li>ImageNet Challenge 2014에서 localisation 1위, classification 2위 (GoogLeNet이 1위)</li>\n</ul>\n\n<h2 id=\"1-introduction\">1. Introduction</h2>\n<ul>\n  <li>Convolutional networks (ConvNets)가 이미지와 영상 인지에서 큰 성과를 보여줌.\n    <ul>\n      <li>예시 1) ILSVRC2013에서 ZFNet은 첫번째 convolutional layer에서 AlexNet보다 작은 filter(window) size와 stride 사이즈를 적용하여 성능향상. (Zeiler &amp; Fergus, 2013; Sermanet et al., 2014).</li>\n      <li>예시 2) (Sermanet et al., 2014; Howard, 2014)에서 training과 testing에서의 scale 조정, data augmentation 등이 연구됨.</li>\n    </ul>\n  </li>\n  <li>본 연구에서는 3x3 convolution filster를 활용하여 망의 깊이(depth)에 집중함.</li>\n  <li>결과적으로, ImageNet 챌린지뿐 아니라 다른 데이터셋에서도 좋은 성과를 보임.</li>\n</ul>\n\n<h2 id=\"2-convnet-configurations\">2. ConvNet Configurations</h2>\n<p>망 구성에 관한 설명.</p>\n<ul>\n  <li>깊이에 의한 향상도를 측정하기 위해 ConvNet layer들이 동일하게 설정됨.</li>\n</ul>\n\n<h3 id=\"21-architecture\">2.1. Architecture</h3>\n<ul>\n  <li>training 중에는, 입력 데이터가 224x224 RGB 이미지로 고정됨.</li>\n  <li>전처리는, 각 pixel에 RGB의 평균값을 빼준다.</li>\n  <li>conv. layers에서 3x3 필터를 사용. stride = 1</li>\n  <li>Max-pooling 2x2 filter, stride = 2</li>\n  <li>추가적으로 특정 설정에서는 1x1 conv. filter를 적용하여, (ReLU를 통한) 추가적인 non-linearity 확보.</li>\n  <li>conv. layers 이후에, 3개의 Fully-Connected(FC) layers를 적용. (각 FC의 출력 채널수: 4096, 4096, 1000)</li>\n  <li>마지막에 soft-max layer 적용.</li>\n  <li>모든 hidden layers에는 ReLU 적용.</li>\n  <li>Local Response Normalisation(LRN) normalisation을 미적용 (Krizhevsky et al., 2012). 적용시, 메모리 소모와 연산 시간 소모 증가를 보임.</li>\n</ul>\n\n<h3 id=\"22-configurations\">2.2. Configurations</h3>\n<ul>\n  <li>A부터 E까지 총 6가지 구성으로 나뉜다. ([Table 1] 참고)\n    <ul>\n      <li>layers의 수와 1x1 conv. layer의 추가 등에 따라 조금씨 다름.</li>\n    </ul>\n  </li>\n</ul>\n\n<h3 id=\"23-discussion\">2.3. Discussion</h3>\n<ul>\n  <li>이전의 연구들이 상대적으로 큰 필터를 사용한 것에 비해, 본 연구는 3x3의 매우 작은 필터와 stride 1을 적용함.\n    <ul>\n      <li>3x3 필터 2개로 5x5 필터의 효과, 3x3 필터 3개로 7x7 필터의 효과를 보며, 오히려 파라미터는 더 적게 사용됨(비용이 작음). (9+9 &lt; 25, 9+9+9 &lt; 49)</li>\n    </ul>\n  </li>\n  <li>1x1 conv. filter를 적용하여, 차원을 유지하며 ReLU를 통한 추가적인 non-linearity 확보.</li>\n</ul>\n\n<h2 id=\"3-classification-framework\">3. Classification Framework</h2>\n<p>training과 evaluation에 관한 설명.</p>\n\n<h3 id=\"31-training\">3.1. Training</h3>\n<ul>\n  <li>optimizer에는, mini-batch gradient descent(SGD)와 momentum(모멘텀) 적용.\n    <ul>\n      <li>batch size = 256, momentum = 0.9</li>\n    </ul>\n  </li>\n  <li>regularisation에는, L2 패널티와 dropout 적용.\n    <ul>\n      <li>dropout은 0.5로 1st 2nd FC에 적용.</li>\n    </ul>\n  </li>\n  <li>learning rate = <script type=\"math/tex\">10^{-2}</script>, 정확도가 향상되지 않을 경우 학습도가 감소하게 설정.</li>\n  <li>Deep net은 학습할 때 vanishing/exploding gradient 문제로 학습이 어려워질 수 있는데, 이것을 먼저 11-layer의 비교적 간단한 구조(A)를 학습시킨 후, 더 깊은 나머지 구조를 학습할 때는 처음 4 layer와 마지막 3개 FC를 구조-A의 학습결과로 초기화 시킨 후 학습을 진행하여 해결하였다.</li>\n</ul>\n\n<p><strong>Training image size</strong></p>\n<ul>\n  <li>data augmentation기법을 적용함.</li>\n  <li>예시) AlexNet, 학습 이미지를 256x256 크기로 만든 후, 무작위로 224x224 크기의 이미지로 잘라서 취함.</li>\n  <li>training scale로 single-scale training과 multi-scaling training 지원.\n    <ul>\n      <li>single-scale에서는 256x256 고정과, 256x256과 384x384를 지원하는 두가지 scale 지원.</li>\n      <li>multi-scale에서는 min = 256, max = 512로 하여, 256과 512범위에서 무작위로 scale을 정할 수 있게 함. 384로 미리 학습시킨 후 무작위로 선택하며 fine tuning을 함. scale jittering이라고 함.</li>\n    </ul>\n  </li>\n  <li>이후 224x224 크기를 선택하여 취함(AlexNet과 동일).</li>\n</ul>\n\n<h3 id=\"32-testing\">3.2. Testing</h3>\n<ul>\n  <li>test scale을 사용하여, 테스트 이미지를 적당한 크기로 조절함.</li>\n  <li>multi-crop 방식(무작위 선택, 코너 및 센터 등의 이미지를 선택하여 좌우반전 적용)의 테스트 이미지 augmentation을 적용. (150장으로 augmentation).</li>\n  <li>연산량을 줄이기 위해 OverFeat 구조에서 사용한 <strong>dense evaluation</strong> 개념을 적용. <br />\n위를 위해 참고 <a href=\"https://laonple.blog.me/220749876381\">[link]</a></li>\n</ul>\n\n<h3 id=\"33-implementation-details\">3.3. Implementation Details</h3>\n<ul>\n  <li>4개의 NVIDIA Titan Black GPU로 하나의 net 구성을 학습시키는데 2-3주 걸림.</li>\n</ul>\n\n<h2 id=\"4-classification-experiments\">4. Classification Experiments</h2>\n<p><strong>Dataset</strong></p>\n<ul>\n  <li>ILSVRC-2012 dataset을 사용.\n    <ul>\n      <li>1000 class</li>\n      <li>sets: training(1.3M images), validation(50k images), testing(100k images with held-out class labels).</li>\n      <li>evaluating measures: the top-1 and top-5 error.</li>\n    </ul>\n  </li>\n</ul>\n\n<h3 id=\"41-single-scale-evaluation\">4.1. Single Scale Evaluation</h3>\n<ul>\n  <li>[Table 3] 참고</li>\n  <li>망이 깊을수록 결과가 좋아지고, 학습에 scale jittering을 적용한 경우에 결과가 더 좋았다.</li>\n  <li>B구조에 3x3 conv. layer 2개를 곂쳐서 사용한 경우와 5x5 conv. layer를 1개 사용하는 모델을 만들어 비교함.\n    <ul>\n      <li>3x3 conv. layer 2개인 모델이 결과가 더 좋았다.</li>\n      <li>망을 깊게 만들고, 파라미터의 크기를 줄이고, 뉴런에 있는 non-linearity 활성함수를 통해 feature 추출 특성이 좋아졌음을 반증함.</li>\n    </ul>\n  </li>\n</ul>\n\n<h3 id=\"42-multi-scale-evaluation\">4.2. Multi-Scale Evaluation</h3>\n<ul>\n  <li>[Table 4] 참고</li>\n  <li>multi-scale test에서 train-scale(S)이 고정된 경우에, {S-32, S, S+32}로 test-scale을 변화시키며 테스트 진행. (train과 test의 scale 차이가 크면 오히려 결과가 좋지 못해서 이와 같이 설정.)</li>\n  <li>학습에 scale jittering을 적용한 경우 출력 크기를 [256, 384,512]로 test 이미지 크기를 정함. 결과는 더 미적용보다 좋았음.</li>\n  <li>single scale보다 multi scale이 결과가 더 좋았음.</li>\n</ul>\n\n<h3 id=\"43-multi-crop-evaluation\">4.3. Multi-Crop Evaluation</h3>\n<ul>\n  <li>[Table 5] 참고</li>\n  <li>multi-crop과 dense evaluation은 각각 적용했을 때와 같이 적용했을 때로 나누어 진행함.</li>\n  <li>함께 진행한 경우, 상보적인 특성을 갖고 있어 성능이 개선되었다고 함.</li>\n</ul>\n\n<h3 id=\"44-convnet-fusion\">4.4. ConvNet Fusion</h3>\n<ul>\n  <li>구조 D와 E에 multi-scale과 multi-crop evaluation, dense evaluation을 적용한 앙상블 구조가 가장 좋은 성과를 보임.</li>\n</ul>\n\n<h3 id=\"45-comparision-with-the-state-of-the-art\">4.5. Comparision with the State-of-the-Art</h3>\n<ul>\n  <li>VGGNet의 위 2개 모델 앙상블이 top-5 val. error와 top-5 test error 6.8%.</li>\n  <li>GoogLeNet의 7개 모델 앙상블이 top-5 val. error와 top-5 test error 6.7%.</li>\n</ul>\n\n<h2 id=\"5-conclusion\">5. Conclusion</h2>\n<ul>\n  <li>망의 깊이가 분류의 정확도에 유익한 영향을 미치며, 챌린지를 통해 기존의 ConvNet 구조에서 망의 깊이 증가를 통해 좋은 성능을 보여줄 수 있음을 알 수 있었음.</li>\n</ul>\n"
      } ,
   
      {
        "title"    : "블로그 건설 중, 다음으로 할 것",
        "category" : "",
        "tags"     : " Test",
        "url"      : "/2018/05/22/next_step.html",
        "date"     : "May 22, 2018",
        "excerpt"  : "<p>드디어 주피터 노트북이 읽히게 만들었다. 다음으로 뭘 할 것인가?   <br />\n<!--more--></p>\n\n<ul>\n  <li>배포하기 (O)</li>\n  <li>동작 확인하기 (O)</li>\n  <li>사이트 제목, 블로그 제목 짓기. (O)</li>\n  <li>나에 대해 쓰기.</li>\n  <li>갤러리에 사진 넣고 글 정리하기. (O)</li>\n  <li>포트폴리오 정리하기. (O… 뭐 일단은)</li>\n  <li>포스팅된...",
        "content"  : "<p>드디어 주피터 노트북이 읽히게 만들었다. 다음으로 뭘 할 것인가?   <br />\n<!--more--></p>\n\n<ul>\n  <li>배포하기 (O)</li>\n  <li>동작 확인하기 (O)</li>\n  <li>사이트 제목, 블로그 제목 짓기. (O)</li>\n  <li>나에 대해 쓰기.</li>\n  <li>갤러리에 사진 넣고 글 정리하기. (O)</li>\n  <li>포트폴리오 정리하기. (O… 뭐 일단은)</li>\n  <li>포스팅된 글 정리하기.  (O)</li>\n</ul>\n"
      } ,
   
      {
        "title"    : "주피터 노트북 테스팅",
        "category" : "",
        "tags"     : " Test",
        "url"      : "/2018/02/10/preparing_data_structure_study.ipynbref",
        "date"     : "February 10, 2018",
        "excerpt"  : "2018-02-10-preparing_data_structure_study.ipynb\n\n",
        "content"  : "2018-02-10-preparing_data_structure_study.ipynb\n\n"
      } 
   ,
   
     {
       
          "title"    : "Creative",
          "category" : "",
          "tags"     : " ",
          "url"      : "/portfolio/safe",
          "date"     : "August 16, 2014",
          "excerpt"  : null,
          "content"  : null
       
     } ,
   
     {
       
          "title"    : "Circus",
          "category" : "",
          "tags"     : " ",
          "url"      : "/portfolio/circus",
          "date"     : "September 1, 2014",
          "excerpt"  : null,
          "content"  : null
       
     } ,
   
     {
       
          "title"    : "Tower of Hanoi",
          "category" : "",
          "tags"     : " ",
          "url"      : "/portfolio/hanoi",
          "date"     : "September 1, 2014",
          "excerpt"  : null,
          "content"  : null
       
     } ,
   
     {
       
          "title"    : "Tic tac toe",
          "category" : "",
          "tags"     : " ",
          "url"      : "/portfolio/tictactoe",
          "date"     : "September 1, 2014",
          "excerpt"  : null,
          "content"  : null
       
     } ,
   
     {
       
          "title"    : "Cake",
          "category" : "",
          "tags"     : " ",
          "url"      : "/portfolio/cake",
          "date"     : "September 27, 2015",
          "excerpt"  : null,
          "content"  : null
       
     } ,
   
     {
       
          "title"    : "Jekyll",
          "category" : "",
          "tags"     : " ",
          "url"      : "/portfolio/jekyllblog",
          "date"     : "May 26, 2017",
          "excerpt"  : null,
          "content"  : null
       
     } ,
   
     {
       
          "title"    : "Lorem Ipsum",
          "category" : "",
          "tags"     : " ",
          "url"      : "/portfolio/submarine",
          "date"     : "September 3, 2017",
          "excerpt"  : null,
          "content"  : null
       
     } ,
   
     {
       
          "title"    : "Github",
          "category" : "",
          "tags"     : " ",
          "url"      : "/portfolio/gitlecture",
          "date"     : "October 20, 2017",
          "excerpt"  : null,
          "content"  : null
       
     } ,
   
     {
       
          "title"    : "Movie App",
          "category" : "",
          "tags"     : " ",
          "url"      : "/portfolio/movie-app",
          "date"     : "December 28, 2018",
          "excerpt"  : null,
          "content"  : null
       
     } 
   
  
]